const { createDocumentService } = require('../../../services/document-service');
const { generateDocumentHash } = require('../../../utils/text-utils');

describe('document-service dedup (unit)', () => {
  function createService({ qdrantRetrievePoints = [], upsertImpl } = {}) {
    const qdrantClient = {
      retrieve: jest.fn(async () => qdrantRetrievePoints),
      upsert: jest.fn(async () => {
        if (typeof upsertImpl === 'function') return upsertImpl(...arguments);
      })
    };

    const embeddingService = {
      estimateTokenCount: () => 1,
      getModelMaxContextTokens: () => 999999,
      getDenseEmbedding: jest.fn(async () => Array.from({ length: 8 }, () => 0.1))
    };

    const service = createDocumentService({
      qdrantClient,
      embeddingService,
      piiService: null,
      categorizationService: null,
      visionService: null,
      descriptionService: null,
      libreOfficeConverter: null,
      pdfParse: null,
      pdf2md: null,
      mammoth: null,
      piiDetectionEnabled: false,
      categorizationModel: null,
      visionEnabled: false,
      autoGenerateDescription: false
    });

    return { service, qdrantClient, embeddingService };
  }

  test('checkForDuplicates returns a map of existing points by id', async () => {
    const { service, qdrantClient } = createService({
      qdrantRetrievePoints: [{ id: 111, payload: { added_at: '2020-01-01T00:00:00.000Z' } }]
    });

    const existing = await service.checkForDuplicates('col', [111, 222]);

    expect(qdrantClient.retrieve).toHaveBeenCalledTimes(1);
    expect(existing.get(111)).toEqual({ id: 111, added_at: '2020-01-01T00:00:00.000Z' });
    expect(existing.has(222)).toBe(false);
  });

  test('processSingleFile sets last_updated equal to added_at for new documents', async () => {
    const { service, qdrantClient } = createService();

    const file = {
      originalname: 'new.txt',
      buffer: Buffer.from('hello')
    };

    await service.processSingleFile(file, 'col', false, {
      existingDocuments: new Map()
    });

    expect(qdrantClient.upsert).toHaveBeenCalledTimes(1);
    const payload = qdrantClient.upsert.mock.calls[0][1].points[0].payload;
    expect(payload.added_at).toBeTruthy();
    expect(payload.last_updated).toBe(payload.added_at);
  });

  test('processSingleFile preserves added_at and updates last_updated for duplicates', async () => {
    const { service, qdrantClient } = createService();
    const hash = generateDocumentHash('dup.txt');
    const existing = new Map([[hash, { id: hash, added_at: '2020-01-01T00:00:00.000Z' }]]);

    const file = {
      originalname: 'dup.txt',
      buffer: Buffer.from('hello')
    };

    await service.processSingleFile(file, 'col', false, {
      existingDocuments: existing
    });

    const payload = qdrantClient.upsert.mock.calls[0][1].points[0].payload;
    expect(payload.added_at).toBe('2020-01-01T00:00:00.000Z');
    expect(payload.last_updated).toBeTruthy();
    expect(payload.last_updated).not.toBe(payload.added_at);
  });
});
