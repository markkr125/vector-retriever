# Hybrid Search Implementation

## Overview

This project implements **weighted hybrid search** using Qdrant's Query API with custom formula-based score fusion. This approach combines semantic understanding (dense vectors) with keyword matching (sparse vectors) while giving you explicit control over the balance.

## Architecture

### Vector Types

**Dense Vector (768D)**
- Generated by: Ollama embedding model (embeddinggemma:latest)
- Type: Cosine similarity
- Purpose: Semantic understanding, synonyms, context
- Score range: Typically 0.6-0.95

**Sparse Vector (10,000D)**
- Generated by: Simple token hashing (`simpleHash()` in utils/text-utils.js)
- Type: Dot product
- Purpose: Keyword matching, exact terms, acronyms
- Score range: Can be 0.5-3.0+ depending on term frequency

### Query API Flow

```javascript
// 1. Generate both vector types
const denseEmbedding = await getDenseEmbedding(query);  // 768D array
const sparseVector = getSparseVector(query);            // {indices, values}

// 2. Dynamic prefetch limit based on pagination
const prefetchLimit = Math.max(100, offset + limit * 2);

// 3. Build prefetch queries
const prefetchQueries = [
  {
    query: denseEmbedding,
    using: 'dense',
    limit: prefetchLimit,
    filter: /* optional filters */
  },
  {
    query: sparseVector,
    using: 'sparse',
    limit: prefetchLimit,
    filter: /* same filters */
  }
];

// 4. Apply weighted formula
const queryParams = {
  prefetch: prefetchQueries,
  query: {
    formula: {
      sum: [
        { mult: [denseWeight, "$score[0]"] },      // Dense weight
        { mult: [1-denseWeight, "$score[1]"] }     // Sparse weight
      ]
    }
  },
  limit: limit,
  offset: offset,
  with_payload: true
};

// 5. Execute query
const results = await qdrantClient.query(collectionName, queryParams);

// 6. Cap scores at 1.0 (100%)
results.points.map(r => ({ ...r, score: Math.min(r.score, 1.0) }));
```

## Weighted Fusion Formula

### The Formula
```
final_score = denseWeight * dense_score + (1 - denseWeight) * sparse_score
```

### Weight Examples

**denseWeight = 0.7** (Default, recommended)
- 70% semantic understanding
- 30% keyword matching
- Best balance for most queries

**denseWeight = 1.0** (Pure semantic)
- 100% semantic, 0% keyword
- Good for: conceptual queries, synonyms, "find similar"
- Bad for: exact term matches, names, IDs

**denseWeight = 0.0** (Pure keyword)
- 0% semantic, 100% keyword
- Good for: exact matches, product codes, specific terms
- Bad for: understanding context, synonyms

**denseWeight = 0.5** (Balanced)
- 50% semantic, 50% keyword
- Treats both equally
- Good for: queries where both matter equally

## Score Normalization

### Why Cap at 1.0?

Different vector types have different score scales:
- Dense (cosine): 0.6-0.95
- Sparse (dot): 0.5-3.0+

Adding weighted scores can produce: `0.7 * 0.85 + 0.3 * 2.5 = 1.345` (134.5%)

**Solution:** Cap all scores at 1.0 after fusion
```javascript
score: Math.min(r.score, 1.0)  // Never exceeds 100%
```

### Consistency Across Pages

Scores are NOT normalized per page. They're consistent across all results:
- Page 1, Result #1: 94%
- Page 3, Result #21: 67%
- Page 10, Result #91: 42%

All percentages are on the same scale, allowing direct comparison.

## Deep Pagination Support

### The Problem

Early implementation used fixed prefetch limit of 100:
```javascript
prefetchQueries = [
  { query: denseEmbedding, using: 'dense', limit: 100 },
  { query: sparseVector, using: 'sparse', limit: 100 }
];
```

This meant:
- ✅ Pages 1-10 worked (offset 0-90)
- ❌ Pages 11+ had no results (offset 100+)

### The Solution

Dynamic prefetch limit based on requested page:
```javascript
const prefetchLimit = Math.max(100, offset + limit * 2);
```

Examples:
- Page 1 (offset 0): prefetch 100 (minimum)
- Page 10 (offset 90): prefetch 110
- Page 20 (offset 190): prefetch 210
- Page 50 (offset 490): prefetch 510

The `* 2` buffer ensures good fusion quality even on deep pages.

## UI Integration

### Dense Weight Slider

Location: `SearchForm.vue`

```vue
<input 
  type="range" 
  min="0" 
  max="1" 
  step="0.05" 
  v-model="denseWeight"
/>
```

- Range: 0.0 to 1.0
- Step: 0.05 (20 positions)
- Default: 0.7
- Updates URL: `?weight=0.7`

### Score Display

Location: `ResultsList.vue`

```vue
<div class="result-score">{{ (result.score * 100).toFixed(1) }}%</div>
```

- Multiplies by 100 for percentage
- Rounds to 1 decimal place
- Examples: "94.3%", "67.8%", "100.0%"

## Performance Characteristics

### Query Latency

Typical hybrid search (50-200ms):
- Dense embedding: 30-80ms (Ollama API)
- Sparse vector generation: <1ms (local)
- Qdrant query: 20-100ms
- Score capping: <1ms

### Prefetch Scaling

| Page | Offset | Prefetch Limit | Performance |
|------|--------|----------------|-------------|
| 1    | 0      | 100            | Fast (~50ms) |
| 10   | 90     | 110            | Fast (~55ms) |
| 20   | 190    | 210            | Medium (~80ms) |
| 50   | 490    | 510            | Slower (~150ms) |
| 100  | 990    | 1010           | Slow (~300ms) |

**Recommendation:** For collections with 10,000+ documents, consider:
1. Server-side cursor/session caching
2. Limiting max page depth
3. Encouraging users to refine search instead of deep pagination

## Comparison: RRF vs Weighted Formula

### RRF (Reciprocal Rank Fusion)

**Formula:**
```
score = 1/(k + rank_dense) + 1/(k + rank_sparse)
```

**Pros:**
- Simple, established algorithm
- Good default behavior
- Normalizes different scales automatically

**Cons:**
- ❌ No weight control
- ❌ Always 50/50 split
- ❌ Can't adjust semantic vs keyword balance
- ❌ Scores often exceed 1.0

### Weighted Formula (Current Implementation)

**Formula:**
```
score = denseWeight * score_dense + (1-denseWeight) * score_sparse
```

**Pros:**
- ✅ Explicit weight control
- ✅ User-adjustable via slider
- ✅ Predictable behavior
- ✅ Scores capped at 100%

**Cons:**
- Requires score capping for different scales
- More complex to implement

### DBSF (Distribution-Based Score Fusion)

**Formula:**
```
score = normalized(score_dense) + normalized(score_sparse)
// Normalized using mean ± 3*stddev
```

**Pros:**
- Handles different scales well
- Statistical normalization

**Cons:**
- ❌ No weight control
- ❌ Always equal split after normalization
- ❌ Can still exceed 1.0 after summing
- Stateless (calculates per-query, not global)

## Debugging Tips

### Check Weight Parameter

Add logging in `routes/search.js`:
```javascript
console.log('Using weighted formula: dense=' + denseWeight + ', sparse=' + (1-denseWeight));
```

Look for: `Using weighted formula: dense=0.7, sparse=0.3`

### Check Raw Scores

Before capping, log raw scores:
```javascript
console.log('Raw scores:', results.points.map(r => r.score));
```

Look for scores >1.0 that need capping.

### Check Prefetch Limit

Verify dynamic calculation:
```javascript
console.log('Prefetch limit:', prefetchLimit, '(offset:', offset, ', limit:', limit, ')');
```

For page 10: `Prefetch limit: 110 (offset: 90, limit: 10)`

### Check Formula Execution

Qdrant executes formula server-side. No client-side visibility, but you can verify:
1. Both prefetch queries have same filter
2. Formula contains `$score[0]` and `$score[1]`
3. Weights sum to 1.0 (e.g., 0.7 + 0.3)

## Common Issues

### "No results on page 11+"

**Cause:** Prefetch limit too low for pagination offset

**Fix:** Already implemented—dynamic prefetch limit

**Verify:**
```bash
# Should see results on all pages
curl "http://localhost:3001/api/search/hybrid?q=test&offset=100&limit=10"
```

### "Scores exceed 100%"

**Cause:** Raw score addition without capping

**Fix:** Already implemented—`Math.min(r.score, 1.0)`

**Verify:** No score should exceed 1.0 in API response

### "Weight slider doesn't change results"

**Cause:** Using RRF/DBSF instead of weighted formula

**Fix:** Check `query` object has `formula` property, not `fusion`

**Verify:**
```javascript
// ✅ Correct
query: { formula: { sum: [...] } }

// ❌ Wrong
query: { fusion: 'rrf' }
```

### "Inconsistent scores across pages"

**Cause:** Per-page normalization (divide by max score per page)

**Fix:** Remove normalization, use raw weighted scores + capping

**Verify:** Score on page 3 should be comparable to score on page 1

## Future Enhancements

### 1. Adaptive Weighting

Automatically adjust weights based on query characteristics:
```javascript
const hasSpecificTerms = query.match(/[A-Z0-9-]+/);
const denseWeight = hasSpecificTerms ? 0.5 : 0.8;
```

### 2. Per-Query Weight Hints

Allow query syntax to override default weight:
```
"find hotels" weight:semantic     // denseWeight=0.9
"Paris" weight:keyword            // denseWeight=0.3
"luxury accommodation" weight:balanced  // denseWeight=0.5
```

### 3. Result Explanation

Show how each result scored:
```json
{
  "id": 123,
  "score": 0.87,
  "explanation": {
    "dense": 0.92,
    "sparse": 0.65,
    "formula": "0.7 * 0.92 + 0.3 * 0.65 = 0.839 (capped at 1.0)"
  }
}
```

### 4. A/B Testing Interface

Compare different weight settings side-by-side:
```
Query: "Amazon order"
Weight 0.5: [result1, result2, ...]
Weight 0.7: [result1, result3, ...]
Weight 0.9: [result2, result1, ...]
```

## References

- [Qdrant Query API Documentation](https://qdrant.tech/documentation/concepts/search/#query-api)
- [Qdrant Hybrid Queries](https://qdrant.tech/documentation/concepts/hybrid-queries/)
- [Score Boosting with Formulas](https://qdrant.tech/documentation/concepts/hybrid-queries/#score-boosting)
- [RRF Paper](https://plg.uwaterloo.ca/~gvcormac/cormacksigir09-rrf.pdf)

## Summary

The current implementation provides:
- ✅ True weighted hybrid search with explicit control
- ✅ Scores capped at 100% for clean UI display
- ✅ Deep pagination support via dynamic prefetch limits
- ✅ Consistent scoring across all pages
- ✅ Fast query execution (50-200ms typical)
- ✅ User-adjustable weight slider in UI

This is production-ready for collections up to ~10,000 documents. For larger collections, consider implementing result caching or cursor-based pagination.
